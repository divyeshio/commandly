{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ui",
  "type": "registry:block",
  "title": "Basic UI",
  "description": "Basic components to render previews, command generation and json output",
  "dependencies": ["react", "lucide-react", "sonner", "zod"],
  "registryDependencies": [
    "button",
    "dialog",
    "input",
    "label",
    "select",
    "textarea",
    "tabs",
    "tooltip",
    "scroll-area",
    "hover-card"
  ],
  "files": [
    {
      "path": "registry/commandly/generated-command.tsx",
      "content": "import { useEffect, useState, useMemo } from \"react\";\nimport { TerminalIcon, CopyIcon, SaveIcon } from \"lucide-react\";\nimport { toast } from \"sonner\";\nimport { Button } from \"@/components/ui/button\";\nimport { getCommandPath } from \"@/registry/commandly/lib/utils/commandly\";\nimport {\n  Parameter,\n  ParameterValue,\n  Tool,\n  Command\n} from \"@/registry/commandly/lib/types/commandly\";\n\ninterface GeneratedCommandProps {\n  tool: Tool;\n  selectedCommand?: Command;\n  parameterValues: Record<string, ParameterValue>;\n  onSaveCommand?: (command: string) => void;\n}\n\nexport function GeneratedCommand({\n  tool,\n  selectedCommand,\n  parameterValues,\n  onSaveCommand\n}: GeneratedCommandProps) {\n  selectedCommand = selectedCommand || tool.commands[0];\n  const [generatedCommand, setGeneratedCommand] = useState(\"\");\n\n  const globalParameters = useMemo(() => {\n    return tool.parameters?.filter((p) => p.isGlobal) || [];\n  }, [tool]);\n\n  const currentParameters = useMemo(() => {\n    return (\n      tool?.parameters?.filter((p) => p.commandId === selectedCommand.id) || []\n    );\n  }, [tool, selectedCommand]);\n\n  useEffect(() => {\n    generateCommand();\n  }, [tool, parameterValues, selectedCommand]);\n\n  const generateCommand = () => {\n    const commandPath = getCommandPath(selectedCommand, tool);\n    let command =\n      tool.name == commandPath ? tool.name : `${tool.name} ${commandPath}`;\n\n    const parametersWithValues: Array<{\n      param: Parameter;\n      value: ParameterValue;\n    }> = [];\n\n    globalParameters.forEach((param) => {\n      const value = parameterValues[param.id];\n      if (value !== undefined && value !== \"\" && value !== false) {\n        parametersWithValues.push({ param, value });\n      }\n    });\n\n    currentParameters.forEach((param) => {\n      const value = parameterValues[param.id];\n      if (\n        value !== undefined &&\n        value !== \"\" &&\n        value !== false &&\n        !param.isGlobal\n      ) {\n        parametersWithValues.push({ param, value });\n      }\n    });\n\n    const positionalParams = parametersWithValues\n      .filter(({ param }) => param.parameterType === \"Argument\")\n      .sort((a, b) => (a.param.position || 0) - (b.param.position || 0));\n\n    parametersWithValues.forEach(({ param, value }) => {\n      if (param.parameterType === \"Flag\") {\n        if (value === true) {\n          const flag = param.shortFlag || param.longFlag;\n          if (flag) command += ` ${flag}`;\n        }\n      } else if (param.parameterType === \"Option\") {\n        const flag = param.shortFlag || param.longFlag;\n        if (flag) {\n          const separator = param.keyValueSeparator ?? \" \";\n          command += ` ${flag}${separator}${value}`;\n        }\n      } else if (param.parameterType === \"Argument\") {\n        command += ` ${value}`;\n      }\n    });\n\n    positionalParams.forEach(({ value }) => {\n      command += ` ${value}`;\n    });\n\n    setGeneratedCommand(command);\n  };\n\n  const copyCommand = () => {\n    navigator.clipboard.writeText(generatedCommand);\n    toast(\"Command copied!\");\n  };\n\n  return (\n    <div>\n      {tool.commands.length === 0 ? (\n        <div className=\"text-center py-8\">\n          <TerminalIcon className=\"h-12 w-12 mx-auto text-muted-foreground mb-4\" />\n          <p className=\"text-muted-foreground\">\n            No commands available for this tool.\n          </p>\n        </div>\n      ) : generatedCommand ? (\n        <div className=\"space-y-4\">\n          <div className=\"bg-muted p-4 rounded font-mono text-sm\">\n            {generatedCommand}\n          </div>\n          <div className=\"flex gap-2\">\n            <Button onClick={copyCommand} variant=\"outline\" className=\"flex-1\">\n              <CopyIcon className=\"h-4 w-4 mr-2\" />\n              Copy Command\n            </Button>\n            {onSaveCommand && (\n              <Button\n                onClick={() => onSaveCommand(generatedCommand)}\n                variant=\"outline\"\n                className=\"flex-1\"\n              >\n                <SaveIcon className=\"h-4 w-4 mr-2\" />\n                Save Command\n              </Button>\n            )}\n          </div>\n        </div>\n      ) : (\n        <div className=\"text-center py-8\">\n          <TerminalIcon className=\"h-12 w-12 mx-auto text-muted-foreground mb-4\" />\n          <p className=\"text-muted-foreground\">\n            Configure parameters to generate the command.\n          </p>\n        </div>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/commandly/generated-command.tsx"
    },
    {
      "path": "registry/commandly/json-output.tsx",
      "content": "import { useEffect, useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { CheckIcon, ChevronsUpDownIcon, CopyIcon } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger\n} from \"@/components/ui/popover\";\nimport {\n  Command as UICommand,\n  CommandGroup,\n  CommandItem,\n  CommandList\n} from \"@/components/ui/command\";\nimport {\n  Card,\n  CardAction,\n  CardContent,\n  CardHeader,\n  CardTitle\n} from \"@/components/ui/card\";\nimport { exportToStructuredJSON } from \"@/registry/commandly/lib/utils/commandly\";\nimport { convertToNestedStructure } from \"@/registry/commandly/lib/utils/commandly-nested\";\nimport { Tool } from \"@/registry/commandly/lib/types/commandly\";\nimport { ScrollArea, ScrollBar } from \"@/components/ui/scroll-area\";\nimport { toast } from \"sonner\";\nimport { useQueryState } from \"nuqs\";\n\nconst jsonOptions = [\n  { value: \"nested\", label: \"Nested\" },\n  { value: \"flat\", label: \"Flat\" }\n];\n\ninterface JsonTypeComponentProps {\n  tool: Tool;\n}\n\nexport function JsonOutput({ tool }: JsonTypeComponentProps) {\n  const [open, setOpen] = useState(false);\n  const [jsonString, setJsonString] = useState<string>();\n  const [jsonType, setJsonType] = useQueryState(\"output\", {\n    defaultValue: \"flat\"\n  });\n  useEffect(() => {\n    const config =\n      jsonType === \"flat\"\n        ? exportToStructuredJSON(tool)\n        : convertToNestedStructure(tool);\n    setJsonString(JSON.stringify(config, null, 2));\n  }, [jsonType, tool]);\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>\n          <span className=\"text-sm\">Output type: </span>\n          <Popover open={open} onOpenChange={setOpen}>\n            <PopoverTrigger asChild>\n              <Button\n                variant=\"outline\"\n                role=\"combobox\"\n                aria-expanded={open}\n                className=\"w-48 justify-between\"\n              >\n                {jsonOptions.find((option) => option.value === jsonType)?.label}\n                <ChevronsUpDownIcon className=\"opacity-50\" />\n              </Button>\n            </PopoverTrigger>\n            <PopoverContent className=\"w-48 p-0\">\n              <UICommand>\n                <CommandList>\n                  <CommandGroup>\n                    {jsonOptions.map((option) => (\n                      <CommandItem\n                        key={option.value}\n                        value={option.value}\n                        onSelect={(currentValue) => {\n                          setJsonType(currentValue);\n                          setOpen(false);\n                        }}\n                      >\n                        {option.label}\n                        <CheckIcon\n                          className={cn(\n                            \"ml-auto h-4 w-4\",\n                            jsonType === option.value\n                              ? \"opacity-100\"\n                              : \"opacity-0\"\n                          )}\n                        />\n                      </CommandItem>\n                    ))}\n                  </CommandGroup>\n                </CommandList>\n              </UICommand>\n            </PopoverContent>\n          </Popover>\n        </CardTitle>\n        <CardAction\n          className=\"rounded-md\"\n          onClick={() => {\n            navigator.clipboard.writeText(jsonString!);\n            toast(\"Copied!\");\n          }}\n        >\n          <CopyIcon className=\"h-4 w-4 dark:stroke-primary\" />\n        </CardAction>\n      </CardHeader>\n      <CardContent>\n        <ScrollArea\n          className=\"[&>[data-radix-scroll-area-viewport]]:max-h-[calc(100vh-320px)] max-w-full\"\n          type=\"hover\"\n        >\n          <pre className=\"rounded-md text-sm font-mono bg-card dark:text-gray-200 max-h max-w-full\">\n            {jsonString}\n          </pre>\n          <ScrollBar orientation=\"vertical\" />\n          <ScrollBar orientation=\"horizontal\" />\n        </ScrollArea>\n      </CardContent>\n    </Card>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/commandly/json-output.tsx"
    },
    {
      "path": "registry/commandly/runtime-preview.tsx",
      "content": "import { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\n\nimport { Badge } from \"@/components/ui/badge\";\nimport { Switch } from \"@/components/ui/switch\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue\n} from \"@/components/ui/select\";\nimport { InfoIcon } from \"lucide-react\";\nimport {\n  Parameter,\n  ParameterValue\n} from \"@/registry/commandly/lib/types/commandly\";\nimport { Command, Tool } from \"@/registry/commandly/lib/types/commandly\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger\n} from \"@/components/ui/tooltip\";\nimport React from \"react\";\n\nconst findDefaultCommand = (tool: Tool): Command | null => {\n  const defaultCommand = tool.commands.find((command) => command.isDefault);\n  if (defaultCommand) return defaultCommand;\n\n  const nameMatchCommand = tool.commands.find(\n    (command) => command.name.toLowerCase() === tool.name.toLowerCase()\n  );\n  if (nameMatchCommand) return nameMatchCommand;\n\n  return tool.commands.length > 0 ? tool.commands[0] : null;\n};\n\ninterface RuntimePreviewProps {\n  selectedCommand?: Command | null;\n  tool: Tool;\n  parameterValues: Record<string, ParameterValue>;\n  updateParameterValue: (parameterId: string, value: ParameterValue) => void;\n}\n\nexport function RuntimePreview({\n  selectedCommand: providedCommand,\n  tool,\n  parameterValues,\n  updateParameterValue\n}: RuntimePreviewProps) {\n  const selectedCommand = providedCommand ?? findDefaultCommand(tool);\n\n  const renderParameterInput = (parameter: Parameter) => {\n    const value = parameterValues[parameter.id] || parameter.defaultValue || \"\";\n\n    switch (parameter.parameterType) {\n      case \"Flag\":\n        return (\n          <div key={parameter.id} className=\"flex items-center space-x-2\">\n            <Switch\n              checked={(parameterValues[parameter.id] as boolean) || false}\n              onCheckedChange={(checked) =>\n                updateParameterValue(parameter.id, checked)\n              }\n            />\n            <Label className=\"flex-1\">\n              {parameter.name}\n              {(parameter.longFlag || parameter.shortFlag) && (\n                <span className=\"text-muted-foreground ml-1\">\n                  (\n                  {[parameter.longFlag, parameter.shortFlag]\n                    .filter(Boolean)\n                    .join(\", \")}\n                  )\n                </span>\n              )}\n              {parameter.isRequired && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n              <Tooltip>\n                <TooltipTrigger>\n                  <InfoIcon className=\"h-3.5 w-3.5\" />\n                </TooltipTrigger>\n                <TooltipContent>\n                  <span>{parameter.description}</span>\n                </TooltipContent>\n              </Tooltip>\n            </Label>\n            {parameter.isGlobal && (\n              <Badge variant=\"outline\" className=\"text-xs\">\n                global\n              </Badge>\n            )}\n          </div>\n        );\n\n      case \"Option\":\n        if (parameter.dataType === \"Enum\") {\n          return (\n            <div key={parameter.id} className=\"space-y-2\">\n              <Label>\n                {parameter.name}\n                {(parameter.longFlag || parameter.shortFlag) && (\n                  <span className=\"text-muted-foreground ml-1\">\n                    (\n                    {[parameter.longFlag, parameter.shortFlag]\n                      .filter(Boolean)\n                      .join(\", \")}\n                    )\n                  </span>\n                )}\n                {parameter.isRequired && (\n                  <span className=\"text-destructive ml-1\">*</span>\n                )}\n                <Tooltip>\n                  <TooltipTrigger>\n                    <InfoIcon className=\"h-3.5 w-3.5\" />\n                  </TooltipTrigger>\n                  <TooltipContent>\n                    <span>{parameter.description}</span>\n                  </TooltipContent>\n                </Tooltip>\n                {parameter.isGlobal && (\n                  <Badge variant=\"outline\" className=\"text-xs ml-2\">\n                    global\n                  </Badge>\n                )}\n              </Label>\n              <Select\n                value={value as string}\n                onValueChange={(newValue) =>\n                  updateParameterValue(parameter.id, newValue)\n                }\n              >\n                <SelectTrigger>\n                  <SelectValue placeholder=\"Select an option\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {parameter.enumValues.map((enumValue) => (\n                    <SelectItem key={enumValue.id} value={enumValue.value}>\n                      {enumValue.displayName || enumValue.value}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n          );\n        } else if (parameter.dataType === \"Boolean\") {\n          return (\n            <div key={parameter.id} className=\"flex items-center space-x-2\">\n              <Switch\n                checked={value === \"true\" || value === true}\n                onCheckedChange={(checked) =>\n                  updateParameterValue(parameter.id, checked.toString())\n                }\n              />\n              <Label className=\"flex-1\">\n                {parameter.name}\n                {(parameter.longFlag || parameter.shortFlag) && (\n                  <span className=\"text-muted-foreground ml-1\">\n                    (\n                    {[parameter.longFlag, parameter.shortFlag]\n                      .filter(Boolean)\n                      .join(\", \")}\n                    )\n                  </span>\n                )}\n                {parameter.isRequired && (\n                  <span className=\"text-destructive ml-1\">*</span>\n                )}\n                <Tooltip>\n                  <TooltipTrigger>\n                    <InfoIcon className=\"h-3.5 w-3.5\" />\n                  </TooltipTrigger>\n                  <TooltipContent>\n                    <span>{parameter.description}</span>\n                  </TooltipContent>\n                </Tooltip>\n              </Label>\n              {parameter.isGlobal && (\n                <Badge variant=\"outline\" className=\"text-xs\">\n                  global\n                </Badge>\n              )}\n            </div>\n          );\n        } else {\n          return (\n            <div key={parameter.id} className=\"space-y-2\">\n              <div className=\"flex\">\n                <Label className=\"flex-1\">\n                  {parameter.name}\n                  {(parameter.longFlag || parameter.shortFlag) && (\n                    <span className=\"text-muted-foreground ml-1\">\n                      (\n                      {[parameter.longFlag, parameter.shortFlag]\n                        .filter(Boolean)\n                        .join(\", \")}\n                      )\n                    </span>\n                  )}\n                  {parameter.isRequired && (\n                    <span className=\"text-destructive ml-1\">*</span>\n                  )}\n                  <Tooltip>\n                    <TooltipTrigger>\n                      <InfoIcon className=\"h-3.5 w-3.5\" />\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <span>{parameter.description}</span>\n                    </TooltipContent>\n                  </Tooltip>\n                </Label>\n                {parameter.isGlobal && (\n                  <Badge variant=\"outline\" className=\"text-xs ml-2\">\n                    global\n                  </Badge>\n                )}\n              </div>\n              <Input\n                type={parameter.dataType === \"Number\" ? \"number\" : \"text\"}\n                value={\n                  parameter.dataType == \"Number\"\n                    ? (value as number)\n                    : (value as string)\n                }\n                onChange={(e) =>\n                  updateParameterValue(parameter.id, e.target.value)\n                }\n                placeholder=\"Enter value\"\n              />\n            </div>\n          );\n        }\n\n      case \"Argument\":\n        return (\n          <div key={parameter.id} className=\"space-y-2\">\n            <Label>\n              {parameter.name}\n              {parameter.isRequired && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n              <Tooltip>\n                <TooltipTrigger>\n                  <InfoIcon className=\"h-3.5 w-3.5\" />\n                </TooltipTrigger>\n                <TooltipContent>\n                  <span>{parameter.description}</span>\n                </TooltipContent>\n              </Tooltip>\n              <Badge variant=\"secondary\" className=\"text-xs ml-2\">\n                {parameter.parameterType}\n                {parameter.parameterType === \"Argument\" &&\n                  parameter.position !== undefined &&\n                  ` (${parameter.position})`}\n              </Badge>\n            </Label>\n            <Input\n              type={parameter.dataType === \"Number\" ? \"number\" : \"text\"}\n              value={\n                parameter.dataType == \"Number\"\n                  ? (value as number)\n                  : (value as string)\n              }\n              onChange={(e) =>\n                updateParameterValue(parameter.id, e.target.value)\n              }\n              placeholder=\"Enter value\"\n            />\n          </div>\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <React.Fragment>\n      {selectedCommand && tool.commands.length === 0 ? (\n        <p className=\"text-muted-foreground text-sm\">\n          No commands available for this tool.\n        </p>\n      ) : (\n        <div className=\"space-y-4\">\n          {tool.parameters.length > 0 ? (\n            tool.parameters\n              .filter(\n                (param) =>\n                  param.commandId === selectedCommand?.id || param.isGlobal\n              )\n              .map(renderParameterInput)\n          ) : (\n            <p className=\"text-muted-foreground text-sm\">\n              No parameters available for this command.\n            </p>\n          )}\n        </div>\n      )}\n    </React.Fragment>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/commandly/runtime-preview.tsx"
    },
    {
      "path": "registry/commandly/lib/types/commandly.ts",
      "content": "import { z } from \"zod/v4\";\n\nexport const CommandSchema = z.object({\n  id: z.uuidv7(),\n  parentCommandId: z.uuidv7().optional(),\n  name: z.string(),\n  description: z.string(),\n  isDefault: z.boolean(),\n  sortOrder: z.number()\n});\nexport type Command = z.infer<typeof CommandSchema>;\n\nexport const ParameterEnumValueSchema = z.object({\n  id: z.uuidv7(),\n  parameterId: z.uuidv7(),\n  value: z.string(),\n  displayName: z.string(),\n  description: z.string(),\n  isDefault: z.boolean(),\n  sortOrder: z.number()\n});\nexport type ParameterEnumValue = z.infer<typeof ParameterEnumValueSchema>;\n\nexport const ParameterValidationTypeSchema = z.enum([\n  \"min_length\",\n  \"max_length\",\n  \"min_value\",\n  \"max_value\",\n  \"regex\"\n]);\nexport type ParameterValidationType = z.infer<\n  typeof ParameterValidationTypeSchema\n>;\n\nexport const ParameterValidationSchema = z.object({\n  id: z.string(),\n  parameterId: z.string(),\n  validationType: ParameterValidationTypeSchema,\n  validationValue: z.string(),\n  errorMessage: z.string()\n});\nexport type ParameterValidation = z.infer<typeof ParameterValidationSchema>;\nexport const ParameterDependencyTypeSchema = z.enum([\n  \"requires\",\n  \"conflicts_with\"\n]);\nexport type ParameterDependencyType = z.infer<\n  typeof ParameterDependencyTypeSchema\n>;\nexport const ParameterDependencySchema = z.object({\n  id: z.string(),\n  parameterId: z.string(),\n  dependsOnParameterId: z.string(),\n  dependencyType: ParameterDependencyTypeSchema,\n  conditionValue: z.string().optional()\n});\n\nexport type ParameterValue = string | number | boolean;\n\nexport type ParameterDependency = z.infer<typeof ParameterDependencySchema>;\n\nexport const ParameterMetadataSchema = z.object({\n  tags: z.array(z.string()).optional()\n});\nexport type ParameterMetadata = z.infer<typeof ParameterMetadataSchema>;\nexport const ParameterTypeSchema = z.enum([\"Flag\", \"Option\", \"Argument\"]);\nexport type ParameterType = z.infer<typeof ParameterTypeSchema>;\n\nexport const ParameterDataTypeSchema = z.enum([\n  \"String\",\n  \"Number\",\n  \"Boolean\",\n  \"Enum\"\n]);\nexport type ParameterDataType = z.infer<typeof ParameterDataTypeSchema>;\n\nexport const ParameterSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  commandId: z.uuidv7().optional(),\n  description: z.string(),\n  metadata: ParameterMetadataSchema.optional(),\n  parameterType: ParameterTypeSchema,\n  dataType: ParameterDataTypeSchema,\n  isRequired: z.boolean(),\n  isRepeatable: z.boolean(),\n  isGlobal: z.boolean(),\n  defaultValue: z.string().optional(),\n  shortFlag: z.string().optional(),\n  longFlag: z.string(),\n  position: z.number().optional(),\n  sortOrder: z.number().optional(),\n  arraySeparator: z.string().optional(),\n  keyValueSeparator: z.string().optional(),\n  enumValues: z.array(ParameterEnumValueSchema),\n  validations: z.array(ParameterValidationSchema).optional(),\n  dependencies: z.array(ParameterDependencySchema).optional()\n});\nexport type Parameter = z.infer<typeof ParameterSchema>;\n\nexport const ExclusionTypeSchema = z.enum([\n  \"mutual_exclusive\",\n  \"required_one_of\"\n]);\nexport type ExclusionType = z.infer<typeof ExclusionTypeSchema>;\n\nexport const ExclusionGroupSchema = z.object({\n  id: z.string().optional(),\n  commandId: z.string().optional(),\n  name: z.string(),\n  exclusionType: ExclusionTypeSchema,\n  parameterIds: z.array(z.string())\n});\nexport type ExclusionGroup = z.infer<typeof ExclusionGroupSchema>;\n\nexport const SavedCommandSchema = z.object({\n  id: z.string(),\n  command: z.string()\n});\nexport type SavedCommand = z.infer<typeof SavedCommandSchema>;\n\nexport const SupportedToolInputTypeSchema = z.enum([\n  \"StandardInput\",\n  \"Parameter\"\n]);\nexport type SupportedToolInputType = z.infer<\n  typeof SupportedToolInputTypeSchema\n>;\n\nexport const SupportedToolOutputTypeSchema = z.enum([\n  \"StandardOutput\",\n  \"File\",\n  \"Directory\"\n]);\nexport type SupportedToolOutputType = z.infer<\n  typeof SupportedToolOutputTypeSchema\n>;\n\nexport const ToolSchema = z.object({\n  id: z.string().optional(),\n  name: z.string(),\n  displayName: z.string(),\n  description: z.string().optional(),\n  version: z.string().optional(),\n  category: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  url: z.url().optional(),\n  commands: z.array(CommandSchema),\n  parameters: z.array(ParameterSchema),\n  exclusionGroups: z.array(ExclusionGroupSchema),\n  supportedInput: z.array(SupportedToolInputTypeSchema),\n  supportedOutput: z.array(SupportedToolOutputTypeSchema)\n});\nexport type Tool = z.infer<typeof ToolSchema>;\n\nexport const AIParseRequestSchema = z.object({\n  helpText: z.string(),\n  toolName: z.string().optional()\n});\nexport type AIParseRequest = z.infer<typeof AIParseRequestSchema>;\n\nexport const AIParseResponseSchema = z.object({\n  success: z.boolean(),\n  data: ToolSchema.optional(),\n  error: z.string().optional()\n});\nexport type AIParseResponse = z.infer<typeof AIParseResponseSchema>;\n\nexport const newToolSchema = z.object({\n  displayName: z.string(),\n  name: z.string(),\n  version: z.string().optional(),\n  description: z.string().optional(),\n  url: z.url().optional()\n});\nexport type ManualNewTool = z.infer<typeof newToolSchema>;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/commandly/lib/types/commandly-nested.ts",
      "content": "import { ParameterValidation, ParameterDependencyType, ParameterType, ParameterDataType, ParameterMetadata, ExclusionType, SupportedToolInputType, SupportedToolOutputType } from \"../../types\";\n\nexport interface NestedCommand {\n  name: string;\n  description: string;\n  isDefault: boolean;\n  sortOrder: number;\n  parameters: NestedParameter[];\n  subcommands: NestedCommand[];\n}\n\nexport interface NestedParameterEnumValue {\n  value: string;\n  displayName: string;\n  description: string;\n  isDefault: boolean;\n  sortOrder: number;\n}\n\nexport type NestedParameterValidation = Omit<\n  ParameterValidation,\n  \"id\" | \"parameterId\"\n>;\n\nexport interface NestedParameterDependency {\n  dependsOnParameter: string;\n  dependencyType: ParameterDependencyType;\n  conditionValue?: string;\n}\n\nexport interface NestedParameter {\n  name: string;\n  description: string;\n  parameterType: ParameterType;\n  dataType: ParameterDataType;\n  metadata?: ParameterMetadata;\n  isRequired: boolean;\n  isRepeatable: boolean;\n  isGlobal: boolean;\n  defaultValue?: string;\n  shortFlag?: string;\n  longFlag: string;\n  position?: number;\n  sortOrder?: number;\n  arraySeparator?: string;\n  keyValueSeparator?: string;\n  enumValues: NestedParameterEnumValue[];\n  validations: NestedParameterValidation[];\n  dependencies: NestedParameterDependency[];\n}\n\nexport interface NestedExclusionGroup {\n  name: string;\n  exclusionType: ExclusionType;\n  parameters: string[];\n}\n\nexport interface NestedTool {\n  name: string;\n  displayName: string;\n  description?: string;\n  version?: string;\n  url?: string;\n  globalParameters: NestedParameter[];\n  commands: NestedCommand[];\n  exclusionGroups: NestedExclusionGroup[];\n  supportedInput: SupportedToolInputType[];\n  supportedOutput: SupportedToolOutputType[];\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/commandly/lib/utils/commandly.ts",
      "content": "import type {\n  Command,\n  Parameter,\n  SavedCommand,\n  Tool\n} from \"@/registry/commandly/lib/types/commandly\";\nimport { v7 as uuidv7 } from \"uuid\";\n\nexport const buildCommandHierarchy = (commands: Command[]): Command[] => {\n  return commands.sort((a, b) => a.sortOrder - b.sortOrder);\n};\n\nexport const getCommandPath = (command: Command, tool: Tool): string => {\n  const findCommandPath = (\n    targetId: string,\n    commands: Command[],\n    path: string[] = []\n  ): string[] | null => {\n    for (const cmd of commands) {\n      if (cmd.name === targetId) {\n        return [...path, cmd.name];\n      }\n\n      const childCommands = commands.filter(\n        (c) => c.parentCommandId === cmd.id\n      );\n      if (childCommands.length > 0) {\n        const subPath = findCommandPath(targetId, childCommands, [\n          ...path,\n          cmd.name\n        ]);\n        if (subPath) {\n          return subPath;\n        }\n      }\n    }\n    return null;\n  };\n\n  const rootCommands = tool.commands.filter((c) => !c.parentCommandId);\n  const path = findCommandPath(command.name, rootCommands);\n\n  if (!path) return command.name;\n\n  if (command.name === tool.name && command.isDefault) {\n    return tool.name;\n  }\n\n  const rootCommand = tool.commands.find((c) => c.name === tool.name);\n  if (rootCommand?.isDefault && path[0] === tool.name) {\n    path[0] = tool.name;\n  }\n\n  return path.join(\" \");\n};\n\nexport const getAllSubcommands = (\n  commandId: string,\n  commands: Command[]\n): Command[] => {\n  const result: Command[] = [];\n\n  const findSubcommands = (parentId: string) => {\n    commands.forEach((cmd) => {\n      if (cmd.parentCommandId === parentId) {\n        result.push(cmd);\n        findSubcommands(cmd.id);\n      }\n    });\n  };\n\n  findSubcommands(commandId);\n  return result;\n};\n\nexport const exportToStructuredJSON = (tool: Tool) => {\n  const flattenCommand = (cmd: Command) => {\n    return { ...cmd };\n  };\n\n  return {\n    name: tool.name,\n    displayName: tool.displayName,\n    description: tool.description,\n    version: tool.version,\n    commands: tool.commands.map(flattenCommand),\n    parameters: tool.parameters,\n    exclusionGroups: tool.exclusionGroups,\n    supportedInput: tool.supportedInput,\n    supportedOutput: tool.supportedOutput\n  };\n};\n\nexport const flattenImportedData = (importedData: any): Tool => {\n  const {\n    name,\n    displayName,\n    parameters = [],\n    commands = [],\n    exclusionGroups = [],\n    supportedInput = [],\n    supportedOutput = []\n  } = importedData;\n\n  const allParameters: Parameter[] = [...parameters];\n\n  const flattenCommandParameters = (\n    command: any,\n    parentId?: string\n  ): Command[] => {\n    const { parameters = [], subcommands = [], ...commandData } = command;\n\n    parameters.forEach((param: any) => {\n      allParameters.push({\n        ...param,\n        commandId: command.id,\n        isGlobal: !command.name\n      });\n    });\n\n    const flatCommand: Command = {\n      ...commandData,\n      parentCommandId: parentId\n    };\n\n    const flatCommands = [flatCommand];\n\n    subcommands.forEach((subcmd: any) => {\n      flatCommands.push(...flattenCommandParameters(subcmd, command.name));\n    });\n\n    return flatCommands;\n  };\n\n  const flatCommands: Command[] = [];\n  commands.forEach((cmd: any) => {\n    flatCommands.push(...flattenCommandParameters(cmd));\n  });\n\n  return {\n    name: name,\n    displayName: displayName || name,\n    commands: flatCommands,\n    parameters: allParameters,\n    exclusionGroups,\n    supportedInput: supportedInput,\n    supportedOutput: supportedOutput\n  };\n};\n\nexport const defaultTool = (toolName?: string, displayName?: string): Tool => {\n  return {\n    name: toolName || \"my-tool\",\n    displayName: displayName || \"My Tool\",\n    description: undefined,\n    version: \"\",\n    commands: [\n      {\n        id: uuidv7(),\n        name: toolName || \"my-tool\",\n        description: \"Main command\",\n        isDefault: true,\n        sortOrder: 0\n      }\n    ],\n    parameters: [\n      {\n        id: \"--help\",\n        name: \"Help\",\n        description: \"Displays help menu of tool\",\n        parameterType: \"Flag\",\n        dataType: \"String\",\n        isRequired: false,\n        isGlobal: true,\n        shortFlag: \"-h\",\n        longFlag: \"--help\",\n        isRepeatable: false,\n        enumValues: [],\n        validations: [],\n        dependencies: []\n      }\n    ],\n    exclusionGroups: [],\n    supportedInput: [\"StandardInput\"],\n    supportedOutput: [\"StandardOutput\"]\n  };\n};\n\nexport const validateDefaultValue = (\n  parameter: Parameter\n): { isValid: boolean; error?: string } => {\n  const { defaultValue, validations, dataType } = parameter;\n\n  if (!defaultValue || !validations) return { isValid: true };\n\n  switch (dataType) {\n    case \"Number\":\n      if (!/^-?\\d+$/.test(defaultValue)) {\n        return { isValid: false, error: \"Default value must be an integer\" };\n      }\n      break;\n    case \"Boolean\":\n      if (![\"true\", \"false\", \"1\", \"0\"].includes(defaultValue.toLowerCase())) {\n        return {\n          isValid: false,\n          error: \"Default value must be true/false or 1/0\"\n        };\n      }\n      break;\n  }\n\n  for (const validation of validations) {\n    const value = dataType === \"Number\" ? Number(defaultValue) : defaultValue;\n\n    switch (validation.validationType) {\n      case \"min_length\":\n        if (\n          typeof value === \"string\" &&\n          value.length < Number(validation.validationValue)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value too short\"\n          };\n        }\n        break;\n      case \"max_length\":\n        if (\n          typeof value === \"string\" &&\n          value.length > Number(validation.validationValue)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value too long\"\n          };\n        }\n        break;\n      case \"min_value\":\n        if (\n          typeof value === \"number\" &&\n          value < Number(validation.validationValue)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value too small\"\n          };\n        }\n        break;\n      case \"max_value\":\n        if (\n          typeof value === \"number\" &&\n          value > Number(validation.validationValue)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value too large\"\n          };\n        }\n        break;\n      case \"regex\":\n        if (\n          typeof value === \"string\" &&\n          !new RegExp(validation.validationValue).test(value)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value doesn't match pattern\"\n          };\n        }\n        break;\n    }\n  }\n\n  return { isValid: true };\n};\n\nexport const createNewCommand = (parentId?: string): Command => {\n  return {\n    id: uuidv7(),\n    parentCommandId: parentId,\n    name: randomCommandName(),\n    description: \"\",\n    isDefault: false,\n    sortOrder: 1\n  };\n};\n\nexport const createNewParameter = (\n  isGlobal: boolean,\n  commandId?: string\n): Parameter => {\n  return {\n    id: uuidv7(),\n    name: \"\",\n    commandId: isGlobal ? undefined : commandId,\n    description: \"\",\n    parameterType: \"Option\",\n    dataType: \"String\",\n    isRequired: false,\n    isRepeatable: false,\n    isGlobal,\n    defaultValue: \"\",\n    shortFlag: \"\",\n    longFlag: \"\",\n    sortOrder: 0,\n    arraySeparator: \",\",\n    keyValueSeparator: \" \",\n    enumValues: [],\n    validations: [],\n    dependencies: []\n  };\n};\n\nexport const getSavedCommandsFromStorage = (toolId: string): SavedCommand[] => {\n  try {\n    const saved = localStorage.getItem(`saved-${toolId}`);\n    return saved ? JSON.parse(saved) : [];\n  } catch {\n    return [];\n  }\n};\n\nexport const saveSavedCommandsToStorage = (\n  toolId: string,\n  commands: SavedCommand[]\n): void => {\n  try {\n    localStorage.setItem(toolId, JSON.stringify(commands));\n  } catch (error) {\n    console.error(\"Failed to save commands to localStorage:\", error);\n  }\n};\n\nexport const addSavedCommandToStorage = (\n  toolId: string,\n  command: SavedCommand\n): void => {\n  const existingCommands = getSavedCommandsFromStorage(toolId);\n  const updatedCommands = [...existingCommands, command];\n  saveSavedCommandsToStorage(toolId, updatedCommands);\n};\n\nexport const removeSavedCommandFromStorage = (\n  toolId: string,\n  commandId: string\n): void => {\n  const existingCommands = getSavedCommandsFromStorage(toolId);\n  const updatedCommands = existingCommands.filter(\n    (cmd) => cmd.id !== commandId\n  );\n  saveSavedCommandsToStorage(toolId, updatedCommands);\n};\n\nexport const clearSavedCommandsFromStorage = (toolId: string): void => {\n  localStorage.removeItem(toolId);\n};\n\nexport const randomCommandName = () => {\n  const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  let result = \"\";\n  const charactersLength = characters.length;\n  for (let i = 0; i < 7; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n};\n\nexport function generateHashCode(s: string): string {\n  let h = 0;\n  for (let i = 0; i < s.length; i++)\n    h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;\n\n  return h.toString();\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/commandly/lib/utils/commandly-nested.ts",
      "content": "import type {\n  Tool,\n  Command,\n  Parameter\n} from \"@/registry/commandly/lib/types/commandly\";\nimport { NestedCommand, NestedExclusionGroup, NestedParameter, NestedTool } from \"../types/commandly-nested\";\n\n\nexport const convertToNestedStructure = (tool: Tool): NestedTool => {\n  const globalParameters = tool.parameters.filter((p) => p.isGlobal);\n\n  const convertParameter = (param: Parameter): NestedParameter => {\n    const { id, commandId, ...rest } = param;\n    return {\n      ...rest,\n      validations:\n        param.validations?.map((v) => {\n          return {\n            validationType: v.validationType,\n            validationValue: v.validationValue,\n            errorMessage: v.errorMessage\n          };\n        }) || [],\n      metadata: param.metadata,\n      dataType: param.dataType,\n      dependencies:\n        param.dependencies?.map((dep) => {\n          const dependsOnParam = tool.parameters.find(\n            (p) => p.id === dep.dependsOnParameterId\n          );\n          return {\n            dependsOnParameter: dependsOnParam?.longFlag || \"\",\n            dependencyType: dep.dependencyType,\n            conditionValue: dep.conditionValue\n          };\n        }) || []\n    };\n  };\n\n  const buildNestedCommands = (\n    commands: Command[],\n    parentId?: string\n  ): NestedCommand[] => {\n    return commands\n      .filter((cmd) => cmd.parentCommandId === parentId)\n      .map((cmd) => {\n        const commandParameters = tool.parameters.filter(\n          (p) => p.commandId === cmd.id && !p.isGlobal\n        );\n        return {\n          name: cmd.name,\n          description: cmd.description,\n          isDefault: cmd.isDefault,\n          sortOrder: cmd.sortOrder,\n          parameters: commandParameters.map(convertParameter),\n          subcommands: buildNestedCommands(commands, cmd.id)\n        };\n      });\n  };\n\n  const nestedExclusionGroups: NestedExclusionGroup[] =\n    tool.exclusionGroups.map((group) => {\n      return {\n        name: group.name,\n        exclusionType: group.exclusionType,\n        parameters: group.parameterIds.map((pid) => {\n          const param = tool.parameters.find((p) => p.id === pid);\n          return param?.longFlag || \"\";\n        })\n      };\n    });\n\n  return {\n    name: tool.name,\n    url: tool.url,\n    displayName: tool.displayName,\n    description: tool.description,\n    version: tool.version,\n    supportedInput: tool.supportedInput,\n    supportedOutput: tool.supportedOutput,\n    globalParameters: globalParameters.map(convertParameter),\n    commands: buildNestedCommands(tool.commands),\n    exclusionGroups: nestedExclusionGroups\n  };\n};\n",
      "type": "registry:lib"
    }
  ]
}
