{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "runtime-preview",
  "type": "registry:component",
  "title": "Runtime Preview",
  "description": "A component that provides real-time preview of CLI command execution and output.",
  "dependencies": ["react"],
  "registryDependencies": ["button", "scroll-area", "tabs"],
  "files": [
    {
      "path": "registry/commandly/runtime-preview.tsx",
      "content": "import { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\n\nimport { Badge } from \"@/components/ui/badge\";\nimport { Switch } from \"@/components/ui/switch\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue\n} from \"@/components/ui/select\";\nimport { InfoIcon } from \"lucide-react\";\nimport {\n  Parameter,\n  ParameterValue\n} from \"@/registry/commandly/lib/types/commandly\";\nimport { Command, Tool } from \"@/registry/commandly/lib/types/commandly\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger\n} from \"@/components/ui/tooltip\";\nimport React from \"react\";\n\nconst findDefaultCommand = (tool: Tool): Command | null => {\n  const defaultCommand = tool.commands.find((command) => command.isDefault);\n  if (defaultCommand) return defaultCommand;\n\n  const nameMatchCommand = tool.commands.find(\n    (command) => command.name.toLowerCase() === tool.name.toLowerCase()\n  );\n  if (nameMatchCommand) return nameMatchCommand;\n\n  return tool.commands.length > 0 ? tool.commands[0] : null;\n};\n\ninterface RuntimePreviewProps {\n  selectedCommand?: Command | null;\n  tool: Tool;\n  parameterValues: Record<string, ParameterValue>;\n  updateParameterValue: (parameterId: string, value: ParameterValue) => void;\n}\n\nexport function RuntimePreview({\n  selectedCommand: providedCommand,\n  tool,\n  parameterValues,\n  updateParameterValue\n}: RuntimePreviewProps) {\n  const selectedCommand = providedCommand ?? findDefaultCommand(tool);\n\n  const renderParameterInput = (parameter: Parameter) => {\n    const value = parameterValues[parameter.id] || parameter.defaultValue || \"\";\n\n    switch (parameter.parameterType) {\n      case \"Flag\":\n        return (\n          <div key={parameter.id} className=\"flex items-center space-x-2\">\n            <Switch\n              checked={(parameterValues[parameter.id] as boolean) || false}\n              onCheckedChange={(checked) =>\n                updateParameterValue(parameter.id, checked)\n              }\n            />\n            <Label className=\"flex-1\">\n              {parameter.name}\n              {(parameter.longFlag || parameter.shortFlag) && (\n                <span className=\"text-muted-foreground ml-1\">\n                  (\n                  {[parameter.longFlag, parameter.shortFlag]\n                    .filter(Boolean)\n                    .join(\", \")}\n                  )\n                </span>\n              )}\n              {parameter.isRequired && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n              <Tooltip>\n                <TooltipTrigger>\n                  <InfoIcon className=\"h-3.5 w-3.5\" />\n                </TooltipTrigger>\n                <TooltipContent>\n                  <span>{parameter.description}</span>\n                </TooltipContent>\n              </Tooltip>\n            </Label>\n            {parameter.isGlobal && (\n              <Badge variant=\"outline\" className=\"text-xs\">\n                global\n              </Badge>\n            )}\n          </div>\n        );\n\n      case \"Option\":\n        if (parameter.dataType === \"Enum\") {\n          return (\n            <div key={parameter.id} className=\"space-y-2\">\n              <Label>\n                {parameter.name}\n                {(parameter.longFlag || parameter.shortFlag) && (\n                  <span className=\"text-muted-foreground ml-1\">\n                    (\n                    {[parameter.longFlag, parameter.shortFlag]\n                      .filter(Boolean)\n                      .join(\", \")}\n                    )\n                  </span>\n                )}\n                {parameter.isRequired && (\n                  <span className=\"text-destructive ml-1\">*</span>\n                )}\n                <Tooltip>\n                  <TooltipTrigger>\n                    <InfoIcon className=\"h-3.5 w-3.5\" />\n                  </TooltipTrigger>\n                  <TooltipContent>\n                    <span>{parameter.description}</span>\n                  </TooltipContent>\n                </Tooltip>\n                {parameter.isGlobal && (\n                  <Badge variant=\"outline\" className=\"text-xs ml-2\">\n                    global\n                  </Badge>\n                )}\n              </Label>\n              <Select\n                value={value as string}\n                onValueChange={(newValue) =>\n                  updateParameterValue(parameter.id, newValue)\n                }\n              >\n                <SelectTrigger>\n                  <SelectValue placeholder=\"Select an option\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {parameter.enumValues.map((enumValue) => (\n                    <SelectItem key={enumValue.id} value={enumValue.value}>\n                      {enumValue.displayName || enumValue.value}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n          );\n        } else if (parameter.dataType === \"Boolean\") {\n          return (\n            <div key={parameter.id} className=\"flex items-center space-x-2\">\n              <Switch\n                checked={value === \"true\" || value === true}\n                onCheckedChange={(checked) =>\n                  updateParameterValue(parameter.id, checked.toString())\n                }\n              />\n              <Label className=\"flex-1\">\n                {parameter.name}\n                {(parameter.longFlag || parameter.shortFlag) && (\n                  <span className=\"text-muted-foreground ml-1\">\n                    (\n                    {[parameter.longFlag, parameter.shortFlag]\n                      .filter(Boolean)\n                      .join(\", \")}\n                    )\n                  </span>\n                )}\n                {parameter.isRequired && (\n                  <span className=\"text-destructive ml-1\">*</span>\n                )}\n                <Tooltip>\n                  <TooltipTrigger>\n                    <InfoIcon className=\"h-3.5 w-3.5\" />\n                  </TooltipTrigger>\n                  <TooltipContent>\n                    <span>{parameter.description}</span>\n                  </TooltipContent>\n                </Tooltip>\n              </Label>\n              {parameter.isGlobal && (\n                <Badge variant=\"outline\" className=\"text-xs\">\n                  global\n                </Badge>\n              )}\n            </div>\n          );\n        } else {\n          return (\n            <div key={parameter.id} className=\"space-y-2\">\n              <div className=\"flex\">\n                <Label className=\"flex-1\">\n                  {parameter.name}\n                  {(parameter.longFlag || parameter.shortFlag) && (\n                    <span className=\"text-muted-foreground ml-1\">\n                      (\n                      {[parameter.longFlag, parameter.shortFlag]\n                        .filter(Boolean)\n                        .join(\", \")}\n                      )\n                    </span>\n                  )}\n                  {parameter.isRequired && (\n                    <span className=\"text-destructive ml-1\">*</span>\n                  )}\n                  <Tooltip>\n                    <TooltipTrigger>\n                      <InfoIcon className=\"h-3.5 w-3.5\" />\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <span>{parameter.description}</span>\n                    </TooltipContent>\n                  </Tooltip>\n                </Label>\n                {parameter.isGlobal && (\n                  <Badge variant=\"outline\" className=\"text-xs ml-2\">\n                    global\n                  </Badge>\n                )}\n              </div>\n              <Input\n                type={parameter.dataType === \"Number\" ? \"number\" : \"text\"}\n                value={\n                  parameter.dataType == \"Number\"\n                    ? (value as number)\n                    : (value as string)\n                }\n                onChange={(e) =>\n                  updateParameterValue(parameter.id, e.target.value)\n                }\n                placeholder=\"Enter value\"\n              />\n            </div>\n          );\n        }\n\n      case \"Argument\":\n        return (\n          <div key={parameter.id} className=\"space-y-2\">\n            <Label>\n              {parameter.name}\n              {parameter.isRequired && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n              <Tooltip>\n                <TooltipTrigger>\n                  <InfoIcon className=\"h-3.5 w-3.5\" />\n                </TooltipTrigger>\n                <TooltipContent>\n                  <span>{parameter.description}</span>\n                </TooltipContent>\n              </Tooltip>\n              <Badge variant=\"secondary\" className=\"text-xs ml-2\">\n                {parameter.parameterType}\n                {parameter.parameterType === \"Argument\" &&\n                  parameter.position !== undefined &&\n                  ` (${parameter.position})`}\n              </Badge>\n            </Label>\n            <Input\n              type={parameter.dataType === \"Number\" ? \"number\" : \"text\"}\n              value={\n                parameter.dataType == \"Number\"\n                  ? (value as number)\n                  : (value as string)\n              }\n              onChange={(e) =>\n                updateParameterValue(parameter.id, e.target.value)\n              }\n              placeholder=\"Enter value\"\n            />\n          </div>\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <React.Fragment>\n      {selectedCommand && tool.commands.length === 0 ? (\n        <p className=\"text-muted-foreground text-sm\">\n          No commands available for this tool.\n        </p>\n      ) : (\n        <div className=\"space-y-4\">\n          {tool.parameters.length > 0 ? (\n            tool.parameters\n              .filter(\n                (param) =>\n                  param.commandId === selectedCommand?.id || param.isGlobal\n              )\n              .map(renderParameterInput)\n          ) : (\n            <p className=\"text-muted-foreground text-sm\">\n              No parameters available for this command.\n            </p>\n          )}\n        </div>\n      )}\n    </React.Fragment>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/commandly/runtime-preview.tsx"
    },
    {
      "path": "registry/commandly/lib/types/commandly.ts",
      "content": "import { z } from \"zod/v4\";\n\nexport const CommandSchema = z.object({\n  id: z.uuidv7(),\n  parentCommandId: z.uuidv7().optional(),\n  name: z.string(),\n  description: z.string(),\n  isDefault: z.boolean(),\n  sortOrder: z.number()\n});\nexport type Command = z.infer<typeof CommandSchema>;\n\nexport const ParameterEnumValueSchema = z.object({\n  id: z.uuidv7(),\n  parameterId: z.uuidv7(),\n  value: z.string(),\n  displayName: z.string(),\n  description: z.string(),\n  isDefault: z.boolean(),\n  sortOrder: z.number()\n});\nexport type ParameterEnumValue = z.infer<typeof ParameterEnumValueSchema>;\n\nexport const ParameterValidationTypeSchema = z.enum([\n  \"min_length\",\n  \"max_length\",\n  \"min_value\",\n  \"max_value\",\n  \"regex\"\n]);\nexport type ParameterValidationType = z.infer<\n  typeof ParameterValidationTypeSchema\n>;\n\nexport const ParameterValidationSchema = z.object({\n  id: z.string(),\n  parameterId: z.string(),\n  validationType: ParameterValidationTypeSchema,\n  validationValue: z.string(),\n  errorMessage: z.string()\n});\nexport type ParameterValidation = z.infer<typeof ParameterValidationSchema>;\nexport const ParameterDependencyTypeSchema = z.enum([\n  \"requires\",\n  \"conflicts_with\"\n]);\nexport type ParameterDependencyType = z.infer<\n  typeof ParameterDependencyTypeSchema\n>;\nexport const ParameterDependencySchema = z.object({\n  id: z.string(),\n  parameterId: z.string(),\n  dependsOnParameterId: z.string(),\n  dependencyType: ParameterDependencyTypeSchema,\n  conditionValue: z.string().optional()\n});\n\nexport type ParameterValue = string | number | boolean;\n\nexport type ParameterDependency = z.infer<typeof ParameterDependencySchema>;\n\nexport const ParameterMetadataSchema = z.object({\n  tags: z.array(z.string()).optional()\n});\nexport type ParameterMetadata = z.infer<typeof ParameterMetadataSchema>;\nexport const ParameterTypeSchema = z.enum([\"Flag\", \"Option\", \"Argument\"]);\nexport type ParameterType = z.infer<typeof ParameterTypeSchema>;\n\nexport const ParameterDataTypeSchema = z.enum([\n  \"String\",\n  \"Number\",\n  \"Boolean\",\n  \"Enum\"\n]);\nexport type ParameterDataType = z.infer<typeof ParameterDataTypeSchema>;\n\nexport const ParameterSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  commandId: z.uuidv7().optional(),\n  description: z.string(),\n  metadata: ParameterMetadataSchema.optional(),\n  parameterType: ParameterTypeSchema,\n  dataType: ParameterDataTypeSchema,\n  isRequired: z.boolean(),\n  isRepeatable: z.boolean(),\n  isGlobal: z.boolean(),\n  defaultValue: z.string().optional(),\n  shortFlag: z.string().optional(),\n  longFlag: z.string(),\n  position: z.number().optional(),\n  sortOrder: z.number().optional(),\n  arraySeparator: z.string().optional(),\n  keyValueSeparator: z.string().optional(),\n  enumValues: z.array(ParameterEnumValueSchema),\n  validations: z.array(ParameterValidationSchema).optional(),\n  dependencies: z.array(ParameterDependencySchema).optional()\n});\nexport type Parameter = z.infer<typeof ParameterSchema>;\n\nexport const ExclusionTypeSchema = z.enum([\n  \"mutual_exclusive\",\n  \"required_one_of\"\n]);\nexport type ExclusionType = z.infer<typeof ExclusionTypeSchema>;\n\nexport const ExclusionGroupSchema = z.object({\n  id: z.string().optional(),\n  commandId: z.string().optional(),\n  name: z.string(),\n  exclusionType: ExclusionTypeSchema,\n  parameterIds: z.array(z.string())\n});\nexport type ExclusionGroup = z.infer<typeof ExclusionGroupSchema>;\n\nexport const SavedCommandSchema = z.object({\n  id: z.string(),\n  command: z.string()\n});\nexport type SavedCommand = z.infer<typeof SavedCommandSchema>;\n\nexport const SupportedToolInputTypeSchema = z.enum([\n  \"StandardInput\",\n  \"Parameter\"\n]);\nexport type SupportedToolInputType = z.infer<\n  typeof SupportedToolInputTypeSchema\n>;\n\nexport const SupportedToolOutputTypeSchema = z.enum([\n  \"StandardOutput\",\n  \"File\",\n  \"Directory\"\n]);\nexport type SupportedToolOutputType = z.infer<\n  typeof SupportedToolOutputTypeSchema\n>;\n\nexport const ToolSchema = z.object({\n  id: z.string().optional(),\n  name: z.string(),\n  displayName: z.string(),\n  description: z.string().optional(),\n  version: z.string().optional(),\n  category: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  url: z.url().optional(),\n  commands: z.array(CommandSchema),\n  parameters: z.array(ParameterSchema),\n  exclusionGroups: z.array(ExclusionGroupSchema),\n  supportedInput: z.array(SupportedToolInputTypeSchema),\n  supportedOutput: z.array(SupportedToolOutputTypeSchema)\n});\nexport type Tool = z.infer<typeof ToolSchema>;\n\nexport const AIParseRequestSchema = z.object({\n  helpText: z.string(),\n  toolName: z.string().optional()\n});\nexport type AIParseRequest = z.infer<typeof AIParseRequestSchema>;\n\nexport const AIParseResponseSchema = z.object({\n  success: z.boolean(),\n  data: ToolSchema.optional(),\n  error: z.string().optional()\n});\nexport type AIParseResponse = z.infer<typeof AIParseResponseSchema>;\n\nexport const newToolSchema = z.object({\n  displayName: z.string(),\n  name: z.string(),\n  version: z.string().optional(),\n  description: z.string().optional(),\n  url: z.url().optional()\n});\nexport type ManualNewTool = z.infer<typeof newToolSchema>;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/commandly/lib/types/commandly-nested.ts",
      "content": "import { ParameterValidation, ParameterDependencyType, ParameterType, ParameterDataType, ParameterMetadata, ExclusionType, SupportedToolInputType, SupportedToolOutputType } from \"../../types\";\n\nexport interface NestedCommand {\n  name: string;\n  description: string;\n  isDefault: boolean;\n  sortOrder: number;\n  parameters: NestedParameter[];\n  subcommands: NestedCommand[];\n}\n\nexport interface NestedParameterEnumValue {\n  value: string;\n  displayName: string;\n  description: string;\n  isDefault: boolean;\n  sortOrder: number;\n}\n\nexport type NestedParameterValidation = Omit<\n  ParameterValidation,\n  \"id\" | \"parameterId\"\n>;\n\nexport interface NestedParameterDependency {\n  dependsOnParameter: string;\n  dependencyType: ParameterDependencyType;\n  conditionValue?: string;\n}\n\nexport interface NestedParameter {\n  name: string;\n  description: string;\n  parameterType: ParameterType;\n  dataType: ParameterDataType;\n  metadata?: ParameterMetadata;\n  isRequired: boolean;\n  isRepeatable: boolean;\n  isGlobal: boolean;\n  defaultValue?: string;\n  shortFlag?: string;\n  longFlag: string;\n  position?: number;\n  sortOrder?: number;\n  arraySeparator?: string;\n  keyValueSeparator?: string;\n  enumValues: NestedParameterEnumValue[];\n  validations: NestedParameterValidation[];\n  dependencies: NestedParameterDependency[];\n}\n\nexport interface NestedExclusionGroup {\n  name: string;\n  exclusionType: ExclusionType;\n  parameters: string[];\n}\n\nexport interface NestedTool {\n  name: string;\n  displayName: string;\n  description?: string;\n  version?: string;\n  url?: string;\n  globalParameters: NestedParameter[];\n  commands: NestedCommand[];\n  exclusionGroups: NestedExclusionGroup[];\n  supportedInput: SupportedToolInputType[];\n  supportedOutput: SupportedToolOutputType[];\n}\n",
      "type": "registry:lib"
    }
  ]
}
