{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "commandly-utils",
  "type": "registry:lib",
  "title": "Commandly Utils",
  "description": "Utility functions for the Commandly tool editor system including command generation and parameter handling.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/commandly/lib/utils/commandly.ts",
      "content": "import type {\n  Command,\n  Parameter,\n  SavedCommand,\n  Tool\n} from \"@/registry/commandly/lib/types/commandly\";\nimport { v7 as uuidv7 } from \"uuid\";\n\nexport const buildCommandHierarchy = (commands: Command[]): Command[] => {\n  return commands.sort((a, b) => a.sortOrder - b.sortOrder);\n};\n\nexport const getCommandPath = (command: Command, tool: Tool): string => {\n  const findCommandPath = (\n    targetId: string,\n    commands: Command[],\n    path: string[] = []\n  ): string[] | null => {\n    for (const cmd of commands) {\n      if (cmd.name === targetId) {\n        return [...path, cmd.name];\n      }\n\n      const childCommands = commands.filter(\n        (c) => c.parentCommandId === cmd.id\n      );\n      if (childCommands.length > 0) {\n        const subPath = findCommandPath(targetId, childCommands, [\n          ...path,\n          cmd.name\n        ]);\n        if (subPath) {\n          return subPath;\n        }\n      }\n    }\n    return null;\n  };\n\n  const rootCommands = tool.commands.filter((c) => !c.parentCommandId);\n  const path = findCommandPath(command.name, rootCommands);\n\n  if (!path) return command.name;\n\n  if (command.name === tool.name && command.isDefault) {\n    return tool.name;\n  }\n\n  const rootCommand = tool.commands.find((c) => c.name === tool.name);\n  if (rootCommand?.isDefault && path[0] === tool.name) {\n    path[0] = tool.name;\n  }\n\n  return path.join(\" \");\n};\n\nexport const getAllSubcommands = (\n  commandId: string,\n  commands: Command[]\n): Command[] => {\n  const result: Command[] = [];\n\n  const findSubcommands = (parentId: string) => {\n    commands.forEach((cmd) => {\n      if (cmd.parentCommandId === parentId) {\n        result.push(cmd);\n        findSubcommands(cmd.id);\n      }\n    });\n  };\n\n  findSubcommands(commandId);\n  return result;\n};\n\nexport const exportToStructuredJSON = (tool: Tool) => {\n  const flattenCommand = (cmd: Command) => {\n    return { ...cmd };\n  };\n\n  return {\n    name: tool.name,\n    displayName: tool.displayName,\n    description: tool.description,\n    version: tool.version,\n    commands: tool.commands.map(flattenCommand),\n    parameters: tool.parameters,\n    exclusionGroups: tool.exclusionGroups,\n    supportedInput: tool.supportedInput,\n    supportedOutput: tool.supportedOutput\n  };\n};\n\nexport const flattenImportedData = (importedData: any): Tool => {\n  const {\n    name,\n    displayName,\n    parameters = [],\n    commands = [],\n    exclusionGroups = [],\n    supportedInput = [],\n    supportedOutput = []\n  } = importedData;\n\n  const allParameters: Parameter[] = [...parameters];\n\n  const flattenCommandParameters = (\n    command: any,\n    parentId?: string\n  ): Command[] => {\n    const { parameters = [], subcommands = [], ...commandData } = command;\n\n    parameters.forEach((param: any) => {\n      allParameters.push({\n        ...param,\n        commandId: command.id,\n        isGlobal: !command.name\n      });\n    });\n\n    const flatCommand: Command = {\n      ...commandData,\n      parentCommandId: parentId\n    };\n\n    const flatCommands = [flatCommand];\n\n    subcommands.forEach((subcmd: any) => {\n      flatCommands.push(...flattenCommandParameters(subcmd, command.name));\n    });\n\n    return flatCommands;\n  };\n\n  const flatCommands: Command[] = [];\n  commands.forEach((cmd: any) => {\n    flatCommands.push(...flattenCommandParameters(cmd));\n  });\n\n  return {\n    name: name,\n    displayName: displayName || name,\n    commands: flatCommands,\n    parameters: allParameters,\n    exclusionGroups,\n    supportedInput: supportedInput,\n    supportedOutput: supportedOutput\n  };\n};\n\nexport const defaultTool = (toolName?: string, displayName?: string): Tool => {\n  return {\n    name: toolName || \"my-tool\",\n    displayName: displayName || \"My Tool\",\n    description: undefined,\n    version: \"\",\n    commands: [\n      {\n        id: uuidv7(),\n        name: toolName || \"my-tool\",\n        description: \"Main command\",\n        isDefault: true,\n        sortOrder: 0\n      }\n    ],\n    parameters: [\n      {\n        id: \"--help\",\n        name: \"Help\",\n        description: \"Displays help menu of tool\",\n        parameterType: \"Flag\",\n        dataType: \"String\",\n        isRequired: false,\n        isGlobal: true,\n        shortFlag: \"-h\",\n        longFlag: \"--help\",\n        isRepeatable: false,\n        enumValues: [],\n        validations: [],\n        dependencies: []\n      }\n    ],\n    exclusionGroups: [],\n    supportedInput: [\"StandardInput\"],\n    supportedOutput: [\"StandardOutput\"]\n  };\n};\n\nexport const validateDefaultValue = (\n  parameter: Parameter\n): { isValid: boolean; error?: string } => {\n  const { defaultValue, validations, dataType } = parameter;\n\n  if (!defaultValue || !validations) return { isValid: true };\n\n  switch (dataType) {\n    case \"Number\":\n      if (!/^-?\\d+$/.test(defaultValue)) {\n        return { isValid: false, error: \"Default value must be an integer\" };\n      }\n      break;\n    case \"Boolean\":\n      if (![\"true\", \"false\", \"1\", \"0\"].includes(defaultValue.toLowerCase())) {\n        return {\n          isValid: false,\n          error: \"Default value must be true/false or 1/0\"\n        };\n      }\n      break;\n  }\n\n  for (const validation of validations) {\n    const value = dataType === \"Number\" ? Number(defaultValue) : defaultValue;\n\n    switch (validation.validationType) {\n      case \"min_length\":\n        if (\n          typeof value === \"string\" &&\n          value.length < Number(validation.validationValue)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value too short\"\n          };\n        }\n        break;\n      case \"max_length\":\n        if (\n          typeof value === \"string\" &&\n          value.length > Number(validation.validationValue)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value too long\"\n          };\n        }\n        break;\n      case \"min_value\":\n        if (\n          typeof value === \"number\" &&\n          value < Number(validation.validationValue)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value too small\"\n          };\n        }\n        break;\n      case \"max_value\":\n        if (\n          typeof value === \"number\" &&\n          value > Number(validation.validationValue)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value too large\"\n          };\n        }\n        break;\n      case \"regex\":\n        if (\n          typeof value === \"string\" &&\n          !new RegExp(validation.validationValue).test(value)\n        ) {\n          return {\n            isValid: false,\n            error: validation.errorMessage || \"Value doesn't match pattern\"\n          };\n        }\n        break;\n    }\n  }\n\n  return { isValid: true };\n};\n\nexport const createNewCommand = (parentId?: string): Command => {\n  return {\n    id: uuidv7(),\n    parentCommandId: parentId,\n    name: randomCommandName(),\n    description: \"\",\n    isDefault: false,\n    sortOrder: 1\n  };\n};\n\nexport const createNewParameter = (\n  isGlobal: boolean,\n  commandId?: string\n): Parameter => {\n  return {\n    id: uuidv7(),\n    name: \"\",\n    commandId: isGlobal ? undefined : commandId,\n    description: \"\",\n    parameterType: \"Option\",\n    dataType: \"String\",\n    isRequired: false,\n    isRepeatable: false,\n    isGlobal,\n    defaultValue: \"\",\n    shortFlag: \"\",\n    longFlag: \"\",\n    sortOrder: 0,\n    arraySeparator: \",\",\n    keyValueSeparator: \" \",\n    enumValues: [],\n    validations: [],\n    dependencies: []\n  };\n};\n\nexport const getSavedCommandsFromStorage = (toolId: string): SavedCommand[] => {\n  try {\n    const saved = localStorage.getItem(`saved-${toolId}`);\n    return saved ? JSON.parse(saved) : [];\n  } catch {\n    return [];\n  }\n};\n\nexport const saveSavedCommandsToStorage = (\n  toolId: string,\n  commands: SavedCommand[]\n): void => {\n  try {\n    localStorage.setItem(toolId, JSON.stringify(commands));\n  } catch (error) {\n    console.error(\"Failed to save commands to localStorage:\", error);\n  }\n};\n\nexport const addSavedCommandToStorage = (\n  toolId: string,\n  command: SavedCommand\n): void => {\n  const existingCommands = getSavedCommandsFromStorage(toolId);\n  const updatedCommands = [...existingCommands, command];\n  saveSavedCommandsToStorage(toolId, updatedCommands);\n};\n\nexport const removeSavedCommandFromStorage = (\n  toolId: string,\n  commandId: string\n): void => {\n  const existingCommands = getSavedCommandsFromStorage(toolId);\n  const updatedCommands = existingCommands.filter(\n    (cmd) => cmd.id !== commandId\n  );\n  saveSavedCommandsToStorage(toolId, updatedCommands);\n};\n\nexport const clearSavedCommandsFromStorage = (toolId: string): void => {\n  localStorage.removeItem(toolId);\n};\n\nexport const randomCommandName = () => {\n  const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  let result = \"\";\n  const charactersLength = characters.length;\n  for (let i = 0; i < 7; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n};\n\nexport function generateHashCode(s: string): string {\n  let h = 0;\n  for (let i = 0; i < s.length; i++)\n    h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;\n\n  return h.toString();\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/commandly/lib/utils/commandly-nested.ts",
      "content": "import type {\n  Tool,\n  Command,\n  Parameter\n} from \"@/registry/commandly/lib/types/commandly\";\nimport { NestedCommand, NestedExclusionGroup, NestedParameter, NestedTool } from \"../types/commandly-nested\";\n\n\nexport const convertToNestedStructure = (tool: Tool): NestedTool => {\n  const globalParameters = tool.parameters.filter((p) => p.isGlobal);\n\n  const convertParameter = (param: Parameter): NestedParameter => {\n    const { id, commandId, ...rest } = param;\n    return {\n      ...rest,\n      validations:\n        param.validations?.map((v) => {\n          return {\n            validationType: v.validationType,\n            validationValue: v.validationValue,\n            errorMessage: v.errorMessage\n          };\n        }) || [],\n      metadata: param.metadata,\n      dataType: param.dataType,\n      dependencies:\n        param.dependencies?.map((dep) => {\n          const dependsOnParam = tool.parameters.find(\n            (p) => p.id === dep.dependsOnParameterId\n          );\n          return {\n            dependsOnParameter: dependsOnParam?.longFlag || \"\",\n            dependencyType: dep.dependencyType,\n            conditionValue: dep.conditionValue\n          };\n        }) || []\n    };\n  };\n\n  const buildNestedCommands = (\n    commands: Command[],\n    parentId?: string\n  ): NestedCommand[] => {\n    return commands\n      .filter((cmd) => cmd.parentCommandId === parentId)\n      .map((cmd) => {\n        const commandParameters = tool.parameters.filter(\n          (p) => p.commandId === cmd.id && !p.isGlobal\n        );\n        return {\n          name: cmd.name,\n          description: cmd.description,\n          isDefault: cmd.isDefault,\n          sortOrder: cmd.sortOrder,\n          parameters: commandParameters.map(convertParameter),\n          subcommands: buildNestedCommands(commands, cmd.id)\n        };\n      });\n  };\n\n  const nestedExclusionGroups: NestedExclusionGroup[] =\n    tool.exclusionGroups.map((group) => {\n      return {\n        name: group.name,\n        exclusionType: group.exclusionType,\n        parameters: group.parameterIds.map((pid) => {\n          const param = tool.parameters.find((p) => p.id === pid);\n          return param?.longFlag || \"\";\n        })\n      };\n    });\n\n  return {\n    name: tool.name,\n    url: tool.url,\n    displayName: tool.displayName,\n    description: tool.description,\n    version: tool.version,\n    supportedInput: tool.supportedInput,\n    supportedOutput: tool.supportedOutput,\n    globalParameters: globalParameters.map(convertParameter),\n    commands: buildNestedCommands(tool.commands),\n    exclusionGroups: nestedExclusionGroups\n  };\n};\n",
      "type": "registry:lib"
    }
  ]
}