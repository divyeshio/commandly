{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "commandly-types",
  "type": "registry:lib",
  "title": "Commandly Types",
  "description": "TypeScript type definitions for the Commandly tool editor system including schemas for tools, commands, and parameters.",
  "dependencies": ["zod"],
  "files": [
    {
      "path": "registry/commandly/lib/types/commandly.ts",
      "content": "import { z } from \"zod/v4\";\n\nexport const CommandSchema = z.object({\n  id: z.uuidv7(),\n  parentCommandId: z.uuidv7().optional(),\n  name: z.string(),\n  description: z.string(),\n  isDefault: z.boolean(),\n  sortOrder: z.number()\n});\nexport type Command = z.infer<typeof CommandSchema>;\n\nexport const ParameterEnumValueSchema = z.object({\n  id: z.uuidv7(),\n  parameterId: z.uuidv7(),\n  value: z.string(),\n  displayName: z.string(),\n  description: z.string(),\n  isDefault: z.boolean(),\n  sortOrder: z.number()\n});\nexport type ParameterEnumValue = z.infer<typeof ParameterEnumValueSchema>;\n\nexport const ParameterValidationTypeSchema = z.enum([\n  \"min_length\",\n  \"max_length\",\n  \"min_value\",\n  \"max_value\",\n  \"regex\"\n]);\nexport type ParameterValidationType = z.infer<\n  typeof ParameterValidationTypeSchema\n>;\n\nexport const ParameterValidationSchema = z.object({\n  id: z.string(),\n  parameterId: z.string(),\n  validationType: ParameterValidationTypeSchema,\n  validationValue: z.string(),\n  errorMessage: z.string()\n});\nexport type ParameterValidation = z.infer<typeof ParameterValidationSchema>;\nexport const ParameterDependencyTypeSchema = z.enum([\n  \"requires\",\n  \"conflicts_with\"\n]);\nexport type ParameterDependencyType = z.infer<\n  typeof ParameterDependencyTypeSchema\n>;\nexport const ParameterDependencySchema = z.object({\n  id: z.string(),\n  parameterId: z.string(),\n  dependsOnParameterId: z.string(),\n  dependencyType: ParameterDependencyTypeSchema,\n  conditionValue: z.string().optional()\n});\n\nexport type ParameterValue = string | number | boolean;\n\nexport type ParameterDependency = z.infer<typeof ParameterDependencySchema>;\n\nexport const ParameterMetadataSchema = z.object({\n  tags: z.array(z.string()).optional()\n});\nexport type ParameterMetadata = z.infer<typeof ParameterMetadataSchema>;\nexport const ParameterTypeSchema = z.enum([\"Flag\", \"Option\", \"Argument\"]);\nexport type ParameterType = z.infer<typeof ParameterTypeSchema>;\n\nexport const ParameterDataTypeSchema = z.enum([\n  \"String\",\n  \"Number\",\n  \"Boolean\",\n  \"Enum\"\n]);\nexport type ParameterDataType = z.infer<typeof ParameterDataTypeSchema>;\n\nexport const ParameterSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  commandId: z.uuidv7().optional(),\n  description: z.string(),\n  metadata: ParameterMetadataSchema.optional(),\n  parameterType: ParameterTypeSchema,\n  dataType: ParameterDataTypeSchema,\n  isRequired: z.boolean(),\n  isRepeatable: z.boolean(),\n  isGlobal: z.boolean(),\n  defaultValue: z.string().optional(),\n  shortFlag: z.string().optional(),\n  longFlag: z.string(),\n  position: z.number().optional(),\n  sortOrder: z.number().optional(),\n  arraySeparator: z.string().optional(),\n  keyValueSeparator: z.string().optional(),\n  enumValues: z.array(ParameterEnumValueSchema),\n  validations: z.array(ParameterValidationSchema).optional(),\n  dependencies: z.array(ParameterDependencySchema).optional()\n});\nexport type Parameter = z.infer<typeof ParameterSchema>;\n\nexport const ExclusionTypeSchema = z.enum([\n  \"mutual_exclusive\",\n  \"required_one_of\"\n]);\nexport type ExclusionType = z.infer<typeof ExclusionTypeSchema>;\n\nexport const ExclusionGroupSchema = z.object({\n  id: z.string().optional(),\n  commandId: z.string().optional(),\n  name: z.string(),\n  exclusionType: ExclusionTypeSchema,\n  parameterIds: z.array(z.string())\n});\nexport type ExclusionGroup = z.infer<typeof ExclusionGroupSchema>;\n\nexport const SavedCommandSchema = z.object({\n  id: z.string(),\n  command: z.string()\n});\nexport type SavedCommand = z.infer<typeof SavedCommandSchema>;\n\nexport const SupportedToolInputTypeSchema = z.enum([\n  \"StandardInput\",\n  \"Parameter\"\n]);\nexport type SupportedToolInputType = z.infer<\n  typeof SupportedToolInputTypeSchema\n>;\n\nexport const SupportedToolOutputTypeSchema = z.enum([\n  \"StandardOutput\",\n  \"File\",\n  \"Directory\"\n]);\nexport type SupportedToolOutputType = z.infer<\n  typeof SupportedToolOutputTypeSchema\n>;\n\nexport const ToolSchema = z.object({\n  id: z.string().optional(),\n  name: z.string(),\n  displayName: z.string(),\n  description: z.string().optional(),\n  version: z.string().optional(),\n  category: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  url: z.url().optional(),\n  commands: z.array(CommandSchema),\n  parameters: z.array(ParameterSchema),\n  exclusionGroups: z.array(ExclusionGroupSchema),\n  supportedInput: z.array(SupportedToolInputTypeSchema),\n  supportedOutput: z.array(SupportedToolOutputTypeSchema)\n});\nexport type Tool = z.infer<typeof ToolSchema>;\n\nexport const AIParseRequestSchema = z.object({\n  helpText: z.string(),\n  toolName: z.string().optional()\n});\nexport type AIParseRequest = z.infer<typeof AIParseRequestSchema>;\n\nexport const AIParseResponseSchema = z.object({\n  success: z.boolean(),\n  data: ToolSchema.optional(),\n  error: z.string().optional()\n});\nexport type AIParseResponse = z.infer<typeof AIParseResponseSchema>;\n\nexport const newToolSchema = z.object({\n  displayName: z.string(),\n  name: z.string(),\n  version: z.string().optional(),\n  description: z.string().optional(),\n  url: z.url().optional()\n});\nexport type ManualNewTool = z.infer<typeof newToolSchema>;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/commandly/lib/types/commandly-nested.ts",
      "content": "import { ParameterValidation, ParameterDependencyType, ParameterType, ParameterDataType, ParameterMetadata, ExclusionType, SupportedToolInputType, SupportedToolOutputType } from \"../../types\";\n\nexport interface NestedCommand {\n  name: string;\n  description: string;\n  isDefault: boolean;\n  sortOrder: number;\n  parameters: NestedParameter[];\n  subcommands: NestedCommand[];\n}\n\nexport interface NestedParameterEnumValue {\n  value: string;\n  displayName: string;\n  description: string;\n  isDefault: boolean;\n  sortOrder: number;\n}\n\nexport type NestedParameterValidation = Omit<\n  ParameterValidation,\n  \"id\" | \"parameterId\"\n>;\n\nexport interface NestedParameterDependency {\n  dependsOnParameter: string;\n  dependencyType: ParameterDependencyType;\n  conditionValue?: string;\n}\n\nexport interface NestedParameter {\n  name: string;\n  description: string;\n  parameterType: ParameterType;\n  dataType: ParameterDataType;\n  metadata?: ParameterMetadata;\n  isRequired: boolean;\n  isRepeatable: boolean;\n  isGlobal: boolean;\n  defaultValue?: string;\n  shortFlag?: string;\n  longFlag: string;\n  position?: number;\n  sortOrder?: number;\n  arraySeparator?: string;\n  keyValueSeparator?: string;\n  enumValues: NestedParameterEnumValue[];\n  validations: NestedParameterValidation[];\n  dependencies: NestedParameterDependency[];\n}\n\nexport interface NestedExclusionGroup {\n  name: string;\n  exclusionType: ExclusionType;\n  parameters: string[];\n}\n\nexport interface NestedTool {\n  name: string;\n  displayName: string;\n  description?: string;\n  version?: string;\n  url?: string;\n  globalParameters: NestedParameter[];\n  commands: NestedCommand[];\n  exclusionGroups: NestedExclusionGroup[];\n  supportedInput: SupportedToolInputType[];\n  supportedOutput: SupportedToolOutputType[];\n}\n",
      "type": "registry:lib"
    }
  ]
}
