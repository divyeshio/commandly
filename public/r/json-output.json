{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "json-output",
  "type": "registry:component",
  "title": "JSON Output",
  "description": "A component for displaying formatted JSON output with syntax highlighting and copy functionality.",
  "dependencies": ["react"],
  "registryDependencies": ["button", "scroll-area"],
  "files": [
    {
      "path": "registry/commandly/json-output.tsx",
      "content": "import { useEffect, useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { CheckIcon, ChevronsUpDownIcon, CopyIcon } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger\n} from \"@/components/ui/popover\";\nimport {\n  Command as UICommand,\n  CommandGroup,\n  CommandItem,\n  CommandList\n} from \"@/components/ui/command\";\nimport {\n  Card,\n  CardAction,\n  CardContent,\n  CardHeader,\n  CardTitle\n} from \"@/components/ui/card\";\nimport { exportToStructuredJSON } from \"@/registry/commandly/lib/utils/commandly\";\nimport { convertToNestedStructure } from \"@/registry/commandly/lib/utils/commandly-nested\";\nimport { Tool } from \"@/registry/commandly/lib/types/commandly\";\nimport { ScrollArea, ScrollBar } from \"@/components/ui/scroll-area\";\nimport { toast } from \"sonner\";\nimport { useQueryState } from \"nuqs\";\n\nconst jsonOptions = [\n  { value: \"nested\", label: \"Nested\" },\n  { value: \"flat\", label: \"Flat\" }\n];\n\ninterface JsonTypeComponentProps {\n  tool: Tool;\n}\n\nexport function JsonOutput({ tool }: JsonTypeComponentProps) {\n  const [open, setOpen] = useState(false);\n  const [jsonString, setJsonString] = useState<string>();\n  const [jsonType, setJsonType] = useQueryState(\"output\", {\n    defaultValue: \"flat\"\n  });\n  useEffect(() => {\n    const config =\n      jsonType === \"flat\"\n        ? exportToStructuredJSON(tool)\n        : convertToNestedStructure(tool);\n    setJsonString(JSON.stringify(config, null, 2));\n  }, [jsonType, tool]);\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>\n          <span className=\"text-sm\">Output type: </span>\n          <Popover open={open} onOpenChange={setOpen}>\n            <PopoverTrigger asChild>\n              <Button\n                variant=\"outline\"\n                role=\"combobox\"\n                aria-expanded={open}\n                className=\"w-48 justify-between\"\n              >\n                {jsonOptions.find((option) => option.value === jsonType)?.label}\n                <ChevronsUpDownIcon className=\"opacity-50\" />\n              </Button>\n            </PopoverTrigger>\n            <PopoverContent className=\"w-48 p-0\">\n              <UICommand>\n                <CommandList>\n                  <CommandGroup>\n                    {jsonOptions.map((option) => (\n                      <CommandItem\n                        key={option.value}\n                        value={option.value}\n                        onSelect={(currentValue) => {\n                          setJsonType(currentValue);\n                          setOpen(false);\n                        }}\n                      >\n                        {option.label}\n                        <CheckIcon\n                          className={cn(\n                            \"ml-auto h-4 w-4\",\n                            jsonType === option.value\n                              ? \"opacity-100\"\n                              : \"opacity-0\"\n                          )}\n                        />\n                      </CommandItem>\n                    ))}\n                  </CommandGroup>\n                </CommandList>\n              </UICommand>\n            </PopoverContent>\n          </Popover>\n        </CardTitle>\n        <CardAction\n          className=\"rounded-md\"\n          onClick={() => {\n            navigator.clipboard.writeText(jsonString!);\n            toast(\"Copied!\");\n          }}\n        >\n          <CopyIcon className=\"h-4 w-4 dark:stroke-primary\" />\n        </CardAction>\n      </CardHeader>\n      <CardContent>\n        <ScrollArea\n          className=\"[&>[data-radix-scroll-area-viewport]]:max-h-[calc(100vh-320px)] max-w-full\"\n          type=\"hover\"\n        >\n          <pre className=\"rounded-md text-sm font-mono bg-card dark:text-gray-200 max-h max-w-full\">\n            {jsonString}\n          </pre>\n          <ScrollBar orientation=\"vertical\" />\n          <ScrollBar orientation=\"horizontal\" />\n        </ScrollArea>\n      </CardContent>\n    </Card>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/commandly/json-output.tsx"
    },
    {
      "path": "registry/commandly/lib/types/commandly.ts",
      "content": "import { z } from \"zod/v4\";\n\nexport const CommandSchema = z.object({\n  id: z.uuidv7(),\n  parentCommandId: z.uuidv7().optional(),\n  name: z.string(),\n  description: z.string(),\n  isDefault: z.boolean(),\n  sortOrder: z.number()\n});\nexport type Command = z.infer<typeof CommandSchema>;\n\nexport const ParameterEnumValueSchema = z.object({\n  id: z.uuidv7(),\n  parameterId: z.uuidv7(),\n  value: z.string(),\n  displayName: z.string(),\n  description: z.string(),\n  isDefault: z.boolean(),\n  sortOrder: z.number()\n});\nexport type ParameterEnumValue = z.infer<typeof ParameterEnumValueSchema>;\n\nexport const ParameterValidationTypeSchema = z.enum([\n  \"min_length\",\n  \"max_length\",\n  \"min_value\",\n  \"max_value\",\n  \"regex\"\n]);\nexport type ParameterValidationType = z.infer<\n  typeof ParameterValidationTypeSchema\n>;\n\nexport const ParameterValidationSchema = z.object({\n  id: z.string(),\n  parameterId: z.string(),\n  validationType: ParameterValidationTypeSchema,\n  validationValue: z.string(),\n  errorMessage: z.string()\n});\nexport type ParameterValidation = z.infer<typeof ParameterValidationSchema>;\nexport const ParameterDependencyTypeSchema = z.enum([\n  \"requires\",\n  \"conflicts_with\"\n]);\nexport type ParameterDependencyType = z.infer<\n  typeof ParameterDependencyTypeSchema\n>;\nexport const ParameterDependencySchema = z.object({\n  id: z.string(),\n  parameterId: z.string(),\n  dependsOnParameterId: z.string(),\n  dependencyType: ParameterDependencyTypeSchema,\n  conditionValue: z.string().optional()\n});\n\nexport type ParameterValue = string | number | boolean;\n\nexport type ParameterDependency = z.infer<typeof ParameterDependencySchema>;\n\nexport const ParameterMetadataSchema = z.object({\n  tags: z.array(z.string()).optional()\n});\nexport type ParameterMetadata = z.infer<typeof ParameterMetadataSchema>;\nexport const ParameterTypeSchema = z.enum([\"Flag\", \"Option\", \"Argument\"]);\nexport type ParameterType = z.infer<typeof ParameterTypeSchema>;\n\nexport const ParameterDataTypeSchema = z.enum([\n  \"String\",\n  \"Number\",\n  \"Boolean\",\n  \"Enum\"\n]);\nexport type ParameterDataType = z.infer<typeof ParameterDataTypeSchema>;\n\nexport const ParameterSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  commandId: z.uuidv7().optional(),\n  description: z.string(),\n  metadata: ParameterMetadataSchema.optional(),\n  parameterType: ParameterTypeSchema,\n  dataType: ParameterDataTypeSchema,\n  isRequired: z.boolean(),\n  isRepeatable: z.boolean(),\n  isGlobal: z.boolean(),\n  defaultValue: z.string().optional(),\n  shortFlag: z.string().optional(),\n  longFlag: z.string(),\n  position: z.number().optional(),\n  sortOrder: z.number().optional(),\n  arraySeparator: z.string().optional(),\n  keyValueSeparator: z.string().optional(),\n  enumValues: z.array(ParameterEnumValueSchema),\n  validations: z.array(ParameterValidationSchema).optional(),\n  dependencies: z.array(ParameterDependencySchema).optional()\n});\nexport type Parameter = z.infer<typeof ParameterSchema>;\n\nexport const ExclusionTypeSchema = z.enum([\n  \"mutual_exclusive\",\n  \"required_one_of\"\n]);\nexport type ExclusionType = z.infer<typeof ExclusionTypeSchema>;\n\nexport const ExclusionGroupSchema = z.object({\n  id: z.string().optional(),\n  commandId: z.string().optional(),\n  name: z.string(),\n  exclusionType: ExclusionTypeSchema,\n  parameterIds: z.array(z.string())\n});\nexport type ExclusionGroup = z.infer<typeof ExclusionGroupSchema>;\n\nexport const SavedCommandSchema = z.object({\n  id: z.string(),\n  command: z.string()\n});\nexport type SavedCommand = z.infer<typeof SavedCommandSchema>;\n\nexport const SupportedToolInputTypeSchema = z.enum([\n  \"StandardInput\",\n  \"Parameter\"\n]);\nexport type SupportedToolInputType = z.infer<\n  typeof SupportedToolInputTypeSchema\n>;\n\nexport const SupportedToolOutputTypeSchema = z.enum([\n  \"StandardOutput\",\n  \"File\",\n  \"Directory\"\n]);\nexport type SupportedToolOutputType = z.infer<\n  typeof SupportedToolOutputTypeSchema\n>;\n\nexport const ToolSchema = z.object({\n  id: z.string().optional(),\n  name: z.string(),\n  displayName: z.string(),\n  description: z.string().optional(),\n  version: z.string().optional(),\n  category: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  url: z.url().optional(),\n  commands: z.array(CommandSchema),\n  parameters: z.array(ParameterSchema),\n  exclusionGroups: z.array(ExclusionGroupSchema),\n  supportedInput: z.array(SupportedToolInputTypeSchema),\n  supportedOutput: z.array(SupportedToolOutputTypeSchema)\n});\nexport type Tool = z.infer<typeof ToolSchema>;\n\nexport const AIParseRequestSchema = z.object({\n  helpText: z.string(),\n  toolName: z.string().optional()\n});\nexport type AIParseRequest = z.infer<typeof AIParseRequestSchema>;\n\nexport const AIParseResponseSchema = z.object({\n  success: z.boolean(),\n  data: ToolSchema.optional(),\n  error: z.string().optional()\n});\nexport type AIParseResponse = z.infer<typeof AIParseResponseSchema>;\n\nexport const newToolSchema = z.object({\n  displayName: z.string(),\n  name: z.string(),\n  version: z.string().optional(),\n  description: z.string().optional(),\n  url: z.url().optional()\n});\nexport type ManualNewTool = z.infer<typeof newToolSchema>;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/commandly/lib/types/commandly-nested.ts",
      "content": "import { ParameterValidation, ParameterDependencyType, ParameterType, ParameterDataType, ParameterMetadata, ExclusionType, SupportedToolInputType, SupportedToolOutputType } from \"../../types\";\n\nexport interface NestedCommand {\n  name: string;\n  description: string;\n  isDefault: boolean;\n  sortOrder: number;\n  parameters: NestedParameter[];\n  subcommands: NestedCommand[];\n}\n\nexport interface NestedParameterEnumValue {\n  value: string;\n  displayName: string;\n  description: string;\n  isDefault: boolean;\n  sortOrder: number;\n}\n\nexport type NestedParameterValidation = Omit<\n  ParameterValidation,\n  \"id\" | \"parameterId\"\n>;\n\nexport interface NestedParameterDependency {\n  dependsOnParameter: string;\n  dependencyType: ParameterDependencyType;\n  conditionValue?: string;\n}\n\nexport interface NestedParameter {\n  name: string;\n  description: string;\n  parameterType: ParameterType;\n  dataType: ParameterDataType;\n  metadata?: ParameterMetadata;\n  isRequired: boolean;\n  isRepeatable: boolean;\n  isGlobal: boolean;\n  defaultValue?: string;\n  shortFlag?: string;\n  longFlag: string;\n  position?: number;\n  sortOrder?: number;\n  arraySeparator?: string;\n  keyValueSeparator?: string;\n  enumValues: NestedParameterEnumValue[];\n  validations: NestedParameterValidation[];\n  dependencies: NestedParameterDependency[];\n}\n\nexport interface NestedExclusionGroup {\n  name: string;\n  exclusionType: ExclusionType;\n  parameters: string[];\n}\n\nexport interface NestedTool {\n  name: string;\n  displayName: string;\n  description?: string;\n  version?: string;\n  url?: string;\n  globalParameters: NestedParameter[];\n  commands: NestedCommand[];\n  exclusionGroups: NestedExclusionGroup[];\n  supportedInput: SupportedToolInputType[];\n  supportedOutput: SupportedToolOutputType[];\n}\n",
      "type": "registry:lib"
    }
  ]
}
